import { GET_TOKEN_URL, GATEWAY_URL } from './constants.mjs';
import WebSocket from 'ws';
import axios from 'axios';
import EventEmitter from 'events';

var EventAck = /* @__PURE__ */ ((EventAck2) => {
  EventAck2["SUCCESS"] = "SUCCESS";
  EventAck2["LATER"] = "LATER";
  return EventAck2;
})(EventAck || {});
const defaultConfig = {
  autoReconnect: true,
  keepAlive: false,
  ua: "",
  subscriptions: [
    {
      type: "EVENT",
      topic: "*"
    }
  ]
};
class DWClient extends EventEmitter {
  debug = false;
  connected = false;
  registered = false;
  reconnecting = false;
  userDisconnect = false;
  reconnectInterval = 1e3;
  heartbeat_interval = 8e3;
  heartbeatIntervallId;
  sslopts = { rejectUnauthorized: true };
  config;
  socket;
  dw_url;
  isAlive = false;
  onEventReceived = (msg) => {
    return { status: "SUCCESS" /* SUCCESS */ };
  };
  constructor(opts) {
    super();
    this.config = {
      ...defaultConfig,
      ...opts
    };
    if (!this.config.clientId || !this.config.clientSecret) {
      console.error("clientId or clientSecret is null");
      throw new Error("clientId or clientSecret is null");
    }
    if (this.config.debug !== void 0) {
      this.debug = this.config.debug;
    }
  }
  getConfig() {
    return { ...this.config };
  }
  printDebug(msg) {
    if (this.debug) {
      const date = "[" + (/* @__PURE__ */ new Date()).toISOString() + "]";
      console.info(date, msg);
    }
  }
  registerAllEventListener(onEventReceived) {
    this.onEventReceived = onEventReceived;
    return this;
  }
  registerCallbackListener(eventId, callback) {
    if (!eventId || !callback) {
      console.error(
        "registerCallbackListener: eventId and callback must be defined"
      );
      throw new Error(
        "registerCallbackListener: eventId and callback must be defined"
      );
    }
    if (!this.config.subscriptions.find(
      (x) => x.topic === eventId && x.type === "CALLBACK"
    )) {
      this.config.subscriptions.push({
        type: "CALLBACK",
        topic: eventId
      });
    }
    this.on(eventId, callback);
    return this;
  }
  async getAccessToken() {
    const result = await axios.get(
      `${GET_TOKEN_URL}?appkey=${this.config.clientId}&appsecret=${this.config.clientSecret}`
    );
    if (result.status === 200 && result.data.access_token) {
      this.config.access_token = result.data.access_token;
      return result.data.access_token;
    } else {
      throw new Error("getAccessToken: get access_token failed");
    }
  }
  async getEndpoint() {
    this.printDebug("get connect endpoint by config");
    this.printDebug(this.config);
    const res = await axios({
      url: GATEWAY_URL,
      method: "POST",
      responseType: "json",
      data: {
        clientId: this.config.clientId,
        clientSecret: this.config.clientSecret,
        ua: this.config.ua,
        subscriptions: this.config.subscriptions
      },
      headers: {
        // 这个接口得加个，否则默认返回的会是xml
        Accept: "application/json"
      }
    });
    this.printDebug("res.data " + JSON.stringify(res.data));
    if (res.data) {
      this.config.endpoint = res.data;
      const { endpoint, ticket } = res.data;
      if (!endpoint || !ticket) {
        this.printDebug("endpoint or ticket is null");
        throw new Error("endpoint or ticket is null");
      }
      this.dw_url = `${endpoint}?ticket=${ticket}`;
      return this;
    } else {
      throw new Error("build: get endpoint failed");
    }
  }
  _connect() {
    return new Promise((resolve, reject) => {
      this.userDisconnect = false;
      this.printDebug("Connecting to dingtalk websocket @ " + this.dw_url);
      this.socket = new WebSocket(this.dw_url, this.sslopts);
      this.socket.on("open", () => {
        this.connected = true;
        console.info("[" + (/* @__PURE__ */ new Date()).toISOString() + "] connect success");
        if (this.config.keepAlive) {
          this.isAlive = true;
          this.heartbeatIntervallId = setInterval(() => {
            var _a, _b;
            if (this.isAlive === false) {
              console.error(
                "TERMINATE SOCKET: Ping Pong does not transfer heartbeat within heartbeat intervall"
              );
              return (_a = this.socket) == null ? void 0 : _a.terminate();
            }
            this.isAlive = false;
            (_b = this.socket) == null ? void 0 : _b.ping("", true);
          }, this.heartbeat_interval);
        }
      });
      this.socket.on("pong", () => {
        this.heartbeat();
      });
      this.socket.on("message", (data) => {
        this.onDownStream(data);
      });
      this.socket.on("close", (err) => {
        this.printDebug("Socket closed");
        this.connected = false;
        this.registered = false;
        if (this.config.autoReconnect && !this.userDisconnect) {
          this.reconnecting = true;
          this.printDebug(
            "Reconnecting in " + this.reconnectInterval / 1e3 + " seconds..."
          );
          setTimeout(this.connect.bind(this), this.reconnectInterval);
        }
      });
      this.socket.on("error", (err) => {
        this.printDebug("SOCKET ERROR");
        console.warn("ERROR", err);
      });
      resolve();
    });
  }
  async connect() {
    await this.getEndpoint();
    await this._connect();
  }
  disconnect() {
    var _a;
    console.info("Disconnecting.");
    this.userDisconnect = true;
    if (this.config.keepAlive && this.heartbeatIntervallId !== void 0) {
      clearInterval(this.heartbeatIntervallId);
    }
    (_a = this.socket) == null ? void 0 : _a.close();
  }
  heartbeat() {
    this.isAlive = true;
    this.printDebug("CLIENT-SIDE HEARTBEAT");
  }
  onDownStream(data) {
    this.printDebug("Received message from dingtalk websocket server");
    const msg = JSON.parse(data);
    this.printDebug(msg);
    switch (msg.type) {
      case "SYSTEM":
        this.onSystem(msg);
        break;
      case "EVENT":
        this.onEvent(msg);
        break;
      case "CALLBACK":
        this.onCallback(msg);
        break;
    }
  }
  onSystem(downstream) {
    var _a;
    switch (downstream.headers.topic) {
      case "CONNECTED": {
        this.printDebug("CONNECTED");
        break;
      }
      case "REGISTERED": {
        this.registered = true;
        this.reconnecting = false;
        break;
      }
      case "disconnect": {
        this.connected = false;
        this.registered = false;
        break;
      }
      case "KEEPALIVE": {
        this.heartbeat();
        break;
      }
      case "ping": {
        this.printDebug("PING");
        (_a = this.socket) == null ? void 0 : _a.send(
          JSON.stringify({
            code: 200,
            headers: downstream.headers,
            message: "OK",
            data: downstream.data
          })
        );
        break;
      }
    }
  }
  onEvent(message) {
    var _a;
    this.printDebug("received event, message=" + JSON.stringify(message));
    const ackData = this.onEventReceived(message);
    (_a = this.socket) == null ? void 0 : _a.send(JSON.stringify({
      code: 200,
      headers: {
        contentType: "application/json",
        messageId: message.headers.messageId
      },
      message: "OK",
      data: JSON.stringify(ackData)
    }));
  }
  onCallback(message) {
    this.emit(message.headers.topic, message);
  }
  send(messageId, value) {
    var _a;
    if (!messageId) {
      console.error("send: messageId must be defined");
      throw new Error("send: messageId must be defined");
    }
    const msg = {
      code: 200,
      headers: {
        contentType: "application/json",
        messageId
      },
      message: "OK",
      data: JSON.stringify(value)
    };
    (_a = this.socket) == null ? void 0 : _a.send(JSON.stringify(msg));
  }
  /**
   * 消息响应，避免服务端重试. 
   * stream模式下，服务端推送消息到client后，会监听client响应，如果消息长时间未响应会在一定时间内(60s)重试推消息，可以通过此方法返回消息响应，避免多次接收服务端消息。
   * @param messageId
   * @param result
   * @returns
   * @memberof DWClient
   * @example
   * ```javascript
   * client.socketResponse(res.headers.messageId, result.data);
   * ```
   */
  socketCallBackResponse(messageId, result) {
    this.send(messageId, { response: result });
  }
  sendGraphAPIResponse(messageId, value) {
    var _a;
    if (!messageId) {
      console.error("send: messageId must be defined");
      throw new Error("send: messageId must be defined");
    }
    const msg = {
      code: 200,
      headers: {
        contentType: "application/json",
        messageId
      },
      message: "OK",
      data: JSON.stringify(value)
    };
    (_a = this.socket) == null ? void 0 : _a.send(JSON.stringify(msg));
  }
}

export { DWClient, EventAck };
